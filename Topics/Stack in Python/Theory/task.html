<h2>Stack in Python</h2>
<html>
 <head></head>
 <body>
  <p>As you already know, <strong>a stack</strong> is a data structure that stores data in the last-in-first-out (LIFO) fashion, meaning that the last element added to the stack will be the first removed from it. The simplest example of a stack in real life is a stack of plates: the ones you put the last are on top, and they are also the first ones that can be removed. Another illustration of a stack is the Tower of Hanoi, a toy that became the inspiration for a famous game. The rings at the very top are the last ones added, but also the first that can be taken away:</p> 
  <p style="text-align: center;"><img alt="" height="238" src="https://ucarecdn.com/1e4e8d90-5c69-4bf6-94c3-b702c9e31d65/" width="408"></p> 
  <p>Stack implements two basic operations: <strong>push</strong>, that adds an element to the stack, and <strong>pop</strong>, that returns its top element and removes it from the stack. Often, the third operation, <strong>peek</strong>, is also supported. It returns the current top element without removing it from the stack.</p> 
  <p>In Python, there is no conventional stack implementation. However, several data structures can be used as one. In this topic, you will learn about some of them.</p> 
  <h5 style="text-align: center;" id="using-lists-as-stack">Using lists as stack</h5> 
  <p>Built-in Python lists implement all the necessary stack functionality, and therefore can be used as such. Indeed, <code class="language-python">append()</code> adds the elements to the list (the analog of the push operator), while <code class="language-python">pop()</code> removes its last element. Note that the top of the stack is actually at the end of the list. Let's take a look at the example:</p> 
  <pre><code class="language-python">my_stack = []

my_stack.append('Out')
my_stack.append('First')
my_stack.append('In')
my_stack.append('Last')

print(my_stack)  # ['Out', 'First', 'In', 'Last']

print(my_stack.pop())  # Last
print(my_stack.pop())  # In
print(my_stack.pop())  # First
print(my_stack.pop())  # Out</code></pre> 
  <p>Nice, isn't it? Well, despite the simplicity of such an approach, using list as a stack isn't a good idea because it can lead to some memory issues. Due to the way lists are implemented in the Python source code, the time complexity of some operations may not be that consistent. When the list grows bigger, Python might need to find a large block of memory to relocate it to, which can slow down some <code class="language-python">append()</code> calls.</p> 
  <h5 style="text-align: center;" id="using-collectionsdeque-as-a-stack">Using collections.deque() as a stack</h5> 
  <p>The problem described above can be avoided by using <strong>deque</strong>.</p> 
  <p>Deque is a linear data structure that supports adding and removing elements from both sides. In Python, you can find deque implementation in the <code class="language-python">collections</code> module. The essential methods are <code class="language-python">append(element)</code> and <code class="language-python">appendleft(element)</code>, which add a new element to the right or left side of the deque respectively, as well as <code class="language-python">pop()</code> and <code class="language-python">popleft()</code>, which remove the first element<strong> </strong>from the corresponding side of the deque.</p> 
  <p>Since deque is implemented as a doubly linked list, its elements don't have to be stored next to each other in memory. By contrast, only smaller chunks of elements are stored together, and each such chunk stores the references to the previous and to the next chunk. This enables faster append operations.</p> 
  <p>You can use deque as a stack in your program. Let's take a look at the example:</p> 
  <pre><code class="language-python">from collections import deque

my_stack = deque()

my_stack.append('k')
my_stack.append('c')
my_stack.append('a')
my_stack.append('t')
my_stack.append('s')

print(my_stack.pop())  # 's'
print(my_stack.pop())  # 't'
print(my_stack.pop())  # 'a'
print(my_stack.pop())  # 'c'
print(my_stack.pop())  # 'k'</code></pre> 
  <p>Note that if you call <code class="language-python">pop()</code> one more time, you will get an exception because there are no more elements in the stack to be popped:</p> 
  <pre><code class="language-python">my_stack.pop()  # IndexError: pop from an empty deque</code></pre> 
  <p>To avoid this, you can always check if the queue is non-empty before trying to get the next element from it. This can be done with the help of <code class="language-python">len()</code>:</p> 
  <pre><code class="language-python">len(my_stack)  # 0

my_stack.append('a')
len(my_stack)  # 1</code></pre> 
  <h5 style="text-align: center;" id="conclusions">Conclusions</h5> 
  <ul> 
   <li>Stack is a LIFO data structure.</li> 
   <li>You can use Python lists as a stack, but it might lead to memory issues.</li> 
   <li><code class="language-python">collections.deque()</code> implements deque as a doubly-linked list.</li> 
   <li>Using deque as a stack in your program enables faster append operations.</li> 
  </ul>
 </body>
</html>
